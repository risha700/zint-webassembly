<!DOCTYPE html>
<html>
  <head>
    <title>JS in-browser barcode maker</title>
    </head>
    <body style="background:powderblue;">
      <h1>Barcode maker</h1>
       <form id="formContainer"> 
        <label>
            <input id="barcodeType" placeholder="barcode type" type="number" value=58>
        </label>
        <label>
            <input id="barcodeText" placeholder="barcode text" type="text" value="anything is possible!">
        </label>
        <button type="submit">Create Barcode</button>
       </form>
    <img src=""/>
      <script type="text/javascript">
        let barcodetxt = document.getElementById('barcodeText')
        let barcodetype = document.getElementById('barcodeType')
        let formContainer = document.getElementById('formContainer')
        formContainer.addEventListener('submit',(e)=>{
            e.preventDefault();
            worker.postMessage({'barcodeType':barcodetype.value, 'barcodeText':barcodetxt.value});
        });
        var canvas = document.createElement('canvas');
        document.body.appendChild(canvas);
        var ctx = canvas.getContext('2d');

        var worker = new Worker('zint-processor.js');

        worker.onmessage = function(e) {drawOutputBitmap(e.data);}
        function requestBarcode(e, data){
            e.preventDefault();
            worker.postMessage(data);

        }
        function drawOutputBitmap(data) {
            console.log("GotData: ", data);
            var arr = new Uint8ClampedArray(data[0][0])
            drawBmpArr(arr,data);
            // let bitmap = setBitmapProperties(arr, data[0][1], data[0][2]);
            // let canvasImgData = convertToImageData(bitmap)
            // ctx.putImageData(canvasImgData, 0, 0);
        }

        function drawBmpArr(arr, data){
            const header_size = 54;
            const width = data[0][1];
            const height = data[0][2];
            const byte_width = 4;
            const image_size = width * height * byte_width;
            // arr = new Uint8Array(header_size + image_size);
            const view = new DataView(arr.buffer);
            
            // // File Header
            // // BM magic number.
            view.setUint16(0, 0x424D, false);
            // console.log("file_size BYTE 0-1", view.getInt32(view.buffer.slice(0,2)));
            // File size.
            view.setUint32(2, arr.length+header_size, true);
            // Offset to image data.
            view.setUint32(10, header_size, true);
            // // BITMAPINFOHEADER
            // Size of BITMAPINFOHEADER
            view.setUint32(14, 40, true);
            // Width
            view.setInt32(18, width, true);
            // Height (signed because negative values flip
            // the image vertically).
            view.setInt32(22, -height, true);//flip bmp
            // Number of colour planes (colours stored as
            // separate images; must be 1).
            view.setUint16(26, 1, true);
            // Bits per pixel.
            view.setUint16(28,24, true);
            // Compression method, 0 = BI_RGB // no copression
            view.setUint32(30, 0, true); 
            // Image size in bytes.
            view.setUint32(34, image_size, true);
            // Horizontal resolution, pixels per metre.
            // This will be unused in this situation.
            view.setInt32(38, 2835, true);
            // Vertical resolution, pixels per metre.
            view.setInt32(42, 2835, true);
            // Number of colours. 0 = all
            view.setUint32(46, 0, true);
            // Number of important colours. 0 = all
            view.setUint32(50, 0, true);

            // Pixel data.  auto handled by Uint8ClampedArray
            // for (let w = 0; w < width; ++w) {
            //     for (let h = 0; h < height; ++h) {
            //         const offset = header_size + (h * width + w) * byte_width;
            //         arr[offset + 0] = 2;     // R value
            //         arr[offset + 1] = h;     // G value
            //         arr[offset + 2] = 255-w; // B value
            //         // arr[offset + 3]//is ignored but must still be present because we specified 32 BPP  
            //     }
            // }

     
            const blob = new Blob([arr], { type: "image/bmp" });
            const url = window.URL.createObjectURL(blob);

            const img = document.getElementsByTagName('img')[0];
            img.src = url;
            
        }

        function setBitmapProperties(arr, width, height){
            let dataview = new DataView(arr.buffer);
            dataview.setUint16(0, 0x424D, false)
            dataview.setUint32(2, arr.length, true);
            dataview.setUint32(10, 54, true);
            dataview.setUint32(14, 40, true);
            dataview.setInt32(18, width, true);
            dataview.setInt32(22, height, true);
            dataview.setUint16(26, 1, true);
            dataview.setUint16(28,24, true);
            dataview.setUint32(30, 0, true); 
            dataview.setUint32(34, width*height*4, true); 
            //file header
            let bitmap={};
            bitmap.fileheader = {};
            bitmap.fileheader.bfType =dataview.getUint16(0, true);
            bitmap.fileheader.bfSize =dataview.getUint32(2, true);
            bitmap.fileheader.bfReserved1 =dataview.getUint16(6, true);
            bitmap.fileheader.bfReserved2 =dataview.getUint16(8, true);
            bitmap.fileheader.bfOffBits =dataview.getUint32(10, true);
            //info header
            bitmap.infoheader = {};
            bitmap.infoheader.biSize =dataview.getUint32(14, true);
            bitmap.infoheader.biWidth =dataview.getUint32(18, true);
            bitmap.infoheader.biHeight =dataview.getUint32(22, true);
            bitmap.infoheader.biPlanes =dataview.getUint16(26, true);
            bitmap.infoheader.biBitCount =dataview.getUint16(28, true);
            bitmap.infoheader.biCompression =dataview.getUint32(30, true);
            bitmap.infoheader.biSizeImage = dataview.getUint32(34, true);
            bitmap.infoheader.biXPelsPerMeter =dataview.getUint32(38, true);
            bitmap.infoheader.biYPelsPerMeter =dataview.getUint32(42, true);
            bitmap.infoheader.biClrUsed =dataview.getUint32(46, true);
            bitmap.infoheader.biClrImportant =dataview.getUint32(50, true);

            // format offset
            var start = bitmap.fileheader.bfOffBits;
            bitmap.stride=Math.floor((bitmap.infoheader.biBitCount*bitmap.infoheader.biWidth +31) / 32) * 4;
            bitmap.pixels =new Uint8Array(arr.buffer, start);
            return bitmap
        }

        function convertToImageData(bitmap, w, h) {
            var Width = w||bitmap.infoheader.biWidth;
            var Height = h||bitmap.infoheader.biHeight;
            var imageData = ctx.createImageData(Width, Height);
            var data = imageData.data;
            var bmpdata = bitmap.pixels;
            var stride = bitmap.stride;

            for (var y = 0; y < Height; ++y) {
            for (var x = 0; x < Width; ++x) {
                var index1 = (x+Width*(Height-y))*4;
                var index2 = x * 3 + stride * y;
                data[index1] = bmpdata[index2 + 2];
                data[index1 + 1] = bmpdata[index2 + 1];
                data[index1 + 2] = bmpdata[index2];
                // data[index1 + 3] = 255;
            }
            }
            return imageData;
            }
      </script>
    </body>
</html>
