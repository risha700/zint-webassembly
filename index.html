<!DOCTYPE html>
<html>
  <head>
    <title>JS in-browser barcode maker</title>
    </head>
    <body style="background:bisque;">
      <h1>Barcode maker</h1>
       <form id="formContainer"> 
        <label>
            <input id="barcodeType" placeholder="barcode type" type="number">
        </label>
        <label>
            <input id="barcodeText" placeholder="barcode text" type="text">
        </label>
        <button type="submit">Create Barcode</button>
       </form>
    <img src=""/>
      <script type="text/javascript">
        let barcodetxt = document.getElementById('barcode-text')
        let barcodetype = document.getElementById('barcode-type')
        let formContainer = document.getElementById('formContainer')
        formContainer.addEventListener('submit',(e)=>{
            e.preventDefault();
            // console.log("PostMSG:", e);
            // console.log(Object.fromEntries(new/ FormData(e.target).entries()));
            worker.postMessage({'barcodeType':1, 'barcodeText':'anytest'});
            // snapshot();

        });
        var canvas = document.createElement('canvas');
        document.body.appendChild(canvas);

        var worker = new Worker('zint-processor.js');

        worker.onmessage = function(e) {
            // console.log('onMsg:', e)
            drawOutputBitmap(e.data);

            // var data = result.buffer;
            
        };
        function requestBarcode(e, data){
            e.preventDefault();
            // console.log("PostMSG:", data);
            worker.postMessage(data);

        }
    function drawOutputBitmap(data) {
        var arr = new Uint32Array(data[0][0])
        var ctx = canvas.getContext('2d');

        const header_size = 54;

        const width = data[0][1];
        const height = data[0][2];
        
        const image_size = width * height * 4;

        // const arr = new Uint8Array(header_size + image_size);
        const view = new DataView(arr.buffer);

            // File Header

        // BM magic number.
        view.setUint16(0, 0x424D, false);
        // File size.
        view.setUint32(2, arr.length, true);
        // Offset to image data.
        view.setUint32(10, header_size, true);

        // BITMAPINFOHEADER

        // Size of BITMAPINFOHEADER
        view.setUint32(14, 40, true);
        // Width
        view.setInt32(18, width, true);
        // Height (signed because negative values flip
        // the image vertically).
        view.setInt32(22, height, true);
        // Number of colour planes (colours stored as
        // separate images; must be 1).
        view.setUint16(26, 1, true);
        // Bits per pixel.
        view.setUint16(28, 32, true);
        // Compression method, 0 = BI_RGB
        view.setUint32(30, 0, true);
        // Image size in bytes.
        view.setUint32(34, image_size, true);
        // Horizontal resolution, pixels per metre.
        // This will be unused in this situation.
        view.setInt32(38, 10000, true);
        // Vertical resolution, pixels per metre.
        view.setInt32(42, 10000, true);
        // Number of colours. 0 = all
        view.setUint32(46, 0, true);
        // Number of important colours. 0 = all
        view.setUint32(50, 0, true);

        // Pixel data.
        for (let w = 0; w < width; ++w) {
        for (let h = 0; h < height; ++h) {
            const offset = header_size + (h * width + w) * 4;
            arr[offset + 0] = w;     // R value
            arr[offset + 1] = h;     // G value
            arr[offset + 2] = 255-w; // B value
            // arr[offset + 3] is ignored but must still be present because we specified 32 BPP
        }
        }

        const blob = new Blob([arr], { type: "image/bmp" });
        const url = window.URL.createObjectURL(blob);

        const img = document.getElementsByTagName('img')[0];
        img.src = url;

        }

      </script>
    </body>
</html>
